{"version":3,"file":"index.umd.js","sources":["../src/index.js"],"sourcesContent":["const { SyncHook } = require('tapable');\r\nconst webpack = require('webpack');\r\nconst nodeExternals = require('webpack-node-externals');\r\n//const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // peer dependency\r\nconst os = require('os');\r\nconst path = require('path');\r\nconst requireFromString = require('require-from-string');\r\nconst NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');\r\nconst NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');\r\nconst LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');\r\nconst SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\r\nconst MultiEntryPlugin = require('webpack/lib/MultiEntryPlugin');\r\nlet HtmlWebpackPlugin; // optional dependency\r\ntry {\r\n  HtmlWebpackPlugin = require('html-webpack-plugin');\r\n} catch (e) {\r\n  if (!(e instanceof Error) || e.code !== 'MODULE_NOT_FOUND') {\r\n    throw e;\r\n  }\r\n}\r\n\r\nconst name = 'PrerenderReactWebpackPlugin';\r\n\r\nclass PrerenderReactWebpackPlugin {\r\n  constructor(options = {}) {\r\n    this.chunks = options.chunks || []; // the chunks to prerender, e.g. \"main\"\r\n    this.assets = []; // filenames that would be emitted\r\n    this.emit = options.emit || false; // whether to emit the prerendering cjs modules\r\n    let res;\r\n    this.hooks = {\r\n      prerendered: new SyncHook([\"defaultExport\"])\r\n    };\r\n  }\r\n\r\n  apply(parentCompiler) {\r\n    const makeHook = this.makeHook.bind(this), emitHook = this.emitHook.bind(this);\r\n    if (parentCompiler.hooks) {\r\n      parentCompiler.hooks.make.tapAsync(name, makeHook);\r\n      parentCompiler.hooks.emit.tapPromise(name, emitHook);\r\n    } else {\r\n      parentCompiler.plugin('make', makeHook);\r\n      parentCompiler.plugin('emit', emitHook);\r\n    }\r\n  }\r\n\r\n  makeHook(compilation, done) {\r\n    const parentCompiler = compilation.compiler;\r\n    const parentOptions = parentCompiler.options;\r\n\r\n    // compilation-specific configuration\r\n    this.prepareData(parentOptions.entry);\r\n\r\n    const outputOptions = {\r\n      filename: '[name].prerender.js', // file format mapping chunks to assets\r\n      futureEmitAssets: true\r\n    };\r\n\r\n    // Only copy over allowed plugins (from prerender-loader)\r\n    const plugins = (parentOptions.plugins || []).filter(c => /(MiniCssExtractPlugin|ExtractTextPlugin)/i.test(c.constructor.name));\r\n\r\n    // Create child compiler to compile a Node version of the app\r\n    let childCompiler = compilation.createChildCompiler('PrerenderReactChildCompiler', outputOptions, plugins);\r\n    childCompiler.outputFileSystem = parentCompiler.outputFileSystem;\r\n    childCompiler.context = parentCompiler.context;\r\n    // don't bundle node_modules\r\n    childCompiler.options.externals = (childCompiler.options.externals || []).concat(nodeExternals());\r\n\r\n    // Compile to CommonJS to be executed by Node\r\n    new NodeTemplatePlugin(outputOptions).apply(childCompiler);\r\n    new NodeTargetPlugin().apply(childCompiler);\r\n    new LibraryTemplatePlugin(name, 'commonjs2').apply(childCompiler);\r\n\r\n    // Add entry plugins to make all of this work\r\n    this.entryPlugins(childCompiler.context).apply(childCompiler);\r\n\r\n    // Needed for HMR. Even if your plugin don't support HMR,\r\n    // this code seems to be always needed just in case to prevent possible errors\r\n    childCompiler.hooks.compilation.tap(name, compilation => {\r\n      if (compilation.cache) {\r\n        if (!compilation.cache[name]) {\r\n          compilation.cache[name] = {};\r\n        }\r\n        compilation.cache = compilation.cache[name];\r\n      }\r\n    });\r\n\r\n    childCompiler.runAsChild((err, entries, childCompilation) => {\r\n      done(err);\r\n    });\r\n  }\r\n\r\n  emitHook(compilation) {\r\n    const stats = compilation.getStats().toJson();\r\n    // Get our output asset\r\n    return Promise.all(this.data.map(({chunk, asset: assetFile, entry}) => {\r\n      const asset = compilation.getAsset(assetFile);\r\n      if (!asset) {\r\n        compilation.errors.push(new Error(`Asset ${assetFile} not found.`));\r\n        return;\r\n      }\r\n      if (!this.emit) {\r\n        // require the generated module and extract the prerendered HTML\r\n        const sourceString = asset.source.source(); // asset.source is Source object (see webpack-sources)\r\n        let sourceExports;\r\n        try {\r\n          sourceExports = requireFromString(sourceString);\r\n        } catch (error) {\r\n          compilation.errors.push(error);\r\n          return;\r\n        }\r\n        if (!sourceExports || !sourceExports.default) {\r\n          compilation.errors.push(new Error(`Missing default export from prerendered chunk ${chunk}`));\r\n          return;\r\n        }\r\n        // should be an HTML snippet or an object of template parameters\r\n        let defaultExport = sourceExports.default;\r\n        if (typeof defaultExport === 'function') {\r\n          defaultExport = defaultExport();\r\n        }\r\n        return Promise.resolve(defaultExport).then(defaultExport => { // handle async export\r\n          console.log(defaultExport);\r\n\r\n          // Delete our asset from output, we got the string we wanted\r\n          delete compilation.assets[assetFile];\r\n\r\n          // Call any plugin tapped into the prerendered hook\r\n          this.hooks.prerendered.call(defaultExport);\r\n        });\r\n      }\r\n    }));\r\n  }\r\n\r\n  hwpHook(compilation) {\r\n    if (HtmlWebpackPlugin && HtmlWebpackPlugin.getHooks) {\r\n      // HtmlWebpackPlugin >= 4\r\n      HtmlWebpackPlugin.getHooks(compilation).beforeAssetTagGeneration.tap(\r\n        name,\r\n        function cb(data, callback) {\r\n          var processTag = self.processTag.bind(self, hwpCompilation);\r\n          data.assetTags.scripts.filter(util.filterTag).forEach(processTag);\r\n          data.assetTags.styles.filter(util.filterTag).forEach(processTag);\r\n          callback(null, data);\r\n        }\r\n      );\r\n    } else if (compilation.hooks.htmlWebpackPluginAlterAssetTags &&\r\n      compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration) {\r\n      // HtmlWebpackPlugin 3\r\n      compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration.tapAsync(name, beforeHtmlGeneration);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize this.data with the information needed to keep track of entry points and outgoing\r\n   * assets. If the array this.options.chunks is present, only prerender those chunks; default to\r\n   * prerendering all chunks.\r\n   *\r\n   * chunk: string = chunk name, ex. main, etc.\r\n   * asset: string = output filename, ex. chunk.prerender.js\r\n   * entry: string | Array<string> = entry point or points, ex. index.js\r\n   *\r\n   * @param entry the entry point given in the parent compiler's options\r\n   */\r\n  prepareData(entry) {\r\n    if (typeof entry === 'string' || Array.isArray(entry)) {\r\n      this.data = [{\r\n        chunk: 'main',\r\n        asset: 'main.prerender.js',\r\n        entry: entry\r\n      }];\r\n    } else {\r\n      this.data = Object.keys(entry).map(chunk => ({\r\n        chunk,\r\n        asset: `${chunk}.prerender.js`,\r\n        entry: entry[chunk]\r\n      }));\r\n      if (Array.isArray(this.chunks) && this.chunks.length) {\r\n        this.data = this.data.filter(({chunk}) => this.chunks.indexOf(chunk) !== -1);\r\n      }\r\n    }\r\n  }\r\n\r\n  // For each object in this.data, apply a Single/MultiEntryPlugin to the compiler\r\n  entryPlugins(context) {\r\n    const plugins = this.data.map(({chunk, entry}) => (\r\n      new (Array.isArray(entry) ? MultiEntryPlugin : SingleEntryPlugin)(context, entry, chunk)\r\n    ));\r\n    return {\r\n      apply(compiler) {\r\n        plugins.forEach(plugin => plugin.apply(compiler));\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = PrerenderReactWebpackPlugin;"],"names":["HtmlWebpackPlugin","require","nodeExternals","requireFromString","NodeTemplatePlugin","NodeTargetPlugin","LibraryTemplatePlugin","SingleEntryPlugin","MultiEntryPlugin","e","Error","code","const","name","PrerenderReactWebpackPlugin","constructor","options","chunks","assets","emit","hooks","SyncHook","apply","parentCompiler","makeHook","this","bind","emitHook","make","tapAsync","tapPromise","plugin","compilation","done","compiler","parentOptions","prepareData","entry","outputOptions","plugins","filter","c","test","childCompiler","createChildCompiler","outputFileSystem","context","externals","concat","entryPlugins","tap","cache","runAsChild","err","entries","childCompilation","getStats","toJson","Promise","all","data","map","ref","asset","getAsset","assetFile","sourceExports","sourceString","source","error","errors","push","default","chunk","defaultExport","resolve","then","console","log","prerendered","call","hwpHook","getHooks","beforeAssetTagGeneration","callback","processTag","self","hwpCompilation","assetTags","scripts","util","filterTag","forEach","styles","htmlWebpackPluginAlterAssetTags","htmlWebpackPluginBeforeHtmlGeneration","beforeHtmlGeneration","Array","isArray","Object","keys","length","indexOf","module","exports"],"mappings":"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"}